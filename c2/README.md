# 第2章

## 练习2\.1

int、long、long long、short所要求的最小占用比特数不同，也因此导致所能表示的范围不同。

无符号数和符号数，无符号数只能表示非负数，符号数的话还可以表示负数，也因此同等大小下两者所能表示的范围往往不同。

float和double所要求的最少有效数字不同，因此通常所占比特数不同，也因此导致所能表示的范围不同。

## 练习 2\.2

我倾向于全部选择double，double的最少10位有效数字（实际16位）通常已经足够计算大多数情况了，由于各数据都有可能含有小数，所以最合适的选择就是double。

## 练习 2\.5

**\(a\)** char, wchat\_t, char\[\], wchar\_t\[\]

**\(b\)** int, unsigned int, long, unsigned long, int\(八进制\), int\(十六进制\)

**\(c\)** double, float, long double

**\(d\)** int, unsigned int, double, double

## 练习 2\.6

上面的是十进制字面值，下面的是八进制字面值，且`09`是错误的，因为八进制的digit只有0到7。

## 练习 2\.7

**\(a\)** 字符串字面值，`"Who goes with Fergus?\n"`

**\(b\)** 扩展精度浮点型字面值，类型是`long double`，值为`31.4`

**\(c\)** 单精度浮点型字面值，类型是`float`，值为`1024.0`

**\(d\)** 扩展精度浮点型字面值，类型是`long double`，值为`3.14`

## 练习 2\.9

**\(a\)** 非法，去掉前面的`std::cin >>`。

**\(b\)** 非法，double转int有丢失信息的风险，可以用列表初始化以外的方式。

**\(c\)** 如果`wage`未定义则非法，反之初始化`salary`为`9999.99`，给`wage`赋值`9999.99`。

**\(d\)** 初始化i为3。

## 练习 2\.10

`global_str`和`local_str`是`""`，`global_int`是`0`，`local_int`未知。

## 练习 2\.11

**\(a\)** 定义 **\(b\)** 定义 **\(c\)** 声明

## 练习 2\.12

**\(a\), \(c\), \(d\)**

## 练习 2\.13

100

## 练习 2\.15

**\(a\)** 合法。

**\(b\)** 不合法，引用类型的初始值必须是一个对象。

**\(c\)** 合法。

**\(d\)** 不合法，引用类型必须被初始化。

## 练习 2\.16

**\(a\)** 合法，给`r2`绑定的对象`d`赋值`3.14159`。

**\(b\)** 合法，给`r2`绑定的对象`d`赋`r1`绑定的对象`i`的值。

**\(c\)** 合法，给`i`赋`r2`绑定的对象`d`清除小数点后数位的值。

**\(d\)** 合法，给`r1`绑定的对象`i`赋`d`清除小数点后数位的值。

## 练习 2\.19

指针本身是一个对象，它是一个地址，我们可以随意愿更改它和它指向的对象。

引用本身不是对象，它是一个别名，引用一旦定义，就不可能绑定其他值，我们可以对它做一切它绑定对象可以做的事情。

## 练习 2\.20

```cpp
int i = 42;         //定义一个名为i的int类型的变量
int *p1 = &i;       //定义一个名为p1的指向i的指针变量
*p1 = *p1 * *p1;    //把p1指向的对象的值和p1指向的对象的值的乘积赋值给p1指向的对象
```
最终`i`的值为1764。

## 练习 2\.21

**\(a\)** 非法，试图把`int`型对象的地址赋值给`double`型的指针。
**\(b\)** 非法，试图把`int`型对象赋值给`int`型指针。
**\(c\)** 合法。

## 练习 2\.22

```cpp
if (p) //若p不是一个空指针，则
if (*p) //若p指向的int对象的值非0
```

## 练习 2\.23

能，看它所被赋的值是否是某个对象的地址（虽然看起来就像是在用结论证明结论一样，但是实际上就是这样）。

## 练习 2\.24

`void *`对象可以存放任何类型的地址，而`long *`对象只可以存放`long`类型的地址。

## 练习 2\.25

**\(a\)** 定义了`int`型的指针`ip`，`int`型对象`i`，`int`型引用`r`并绑定到`i`上。

**\(b\)** 定义了`int`型的对象i，`int`型的指针`ip`并初始化为空指针。

**\(c\)** 定义了`int`型指针`ip`，`int`型对象`ip2`

## 练习 2\.26

**\(a\)** 不合法，没有初始化。

**\(b\)** 合法。

**\(c\)** 合法。

**\(d\)** `++cnt`合法，`++sz`不合法，因为`const`类型的对象是只读的。

## 练习 2\.27

**\(a\)** 不合法，非常量引用类型的初始值必须是一个对象。

**\(b\)** 若`i2`是一个`int`型变量合法，反之不然。

**\(c\)** 合法，`r`是一个常量引用。

**\(d\)** 若`i2`是一个`int`型对象则合法，反之不然。

**\(e\)** 若`i2`是一个`int`型对象则合法，反之不然。

**\(f\)** 不合法，引用不能是`const`。

**\(g\)** 若`i`是可以隐式地转换为`int`的值则合法，反之不然。

## 练习 2\.28

**\(a\)** 定义了一个`int`型常量`i`，`*const cp`不合法，常量指针必须初始化。

**\(b\)** 定义了一个指向`int`型对象的指针`p1`，`*const p2`不合法，常量指针必须初始化。

**\(c\)** `const int ic`不合法，常量必须初始化。定义了一个`int`型常量引用`r`绑定到`ic`上。

**\(d\)** 不合法，常量指针必须初始化。

**\(e\)** 定义了一个指向`int`型常量的指针`p`。

## 练习 2\.29

**\(a\)** 合法，`ic`的值被赋给了`i`。

**\(b\)** 不合法，`p1`和`p3`指向的对象类型不同。

**\(c\)** 不合法，`p1`指向的是一个`int`型变量，而`ic`是一个`int`型常量。

**\(d\)** 不合法，不可以改变常量指针的值。

**\(e\)** 不合法，不可以改变常量指针的值。

**\(f\)** 不合法，不可以改变常量的值。

## 练习 2\.30

```cpp
const int v2 = 0;   //v2具有顶层const的定义
int v1 = v2;
int *p1 = &v1, &r1 = v1;
const int *p2 = &v2, *const p3 = &i, &r2 = v2;
                    //p2和r2具有底层const的定义
                    //p3具有顶层和底层const的定义
```

## 练习 2\.31

```cpp
r1 = v2;    //合法，v2的const是一个顶层const
p1 = p2;    //不合法，p1没有底层const，而p2具有底层const的定义
p2 = p1;    //合法，底层const资格不同时，允许把不具有底层const的对象赋值给具有底层const的对象
p1 = p3;    //不合法，p1没有底层const，而p3具有底层const的定义。
p2 = p3;    //合法，p2和p3同具有底层const定义。
```

## 练习 2\.32

不合法，虽然`null`并不是关键字不会影响定义，但是`int`型变量无论取什么值都不能直接作为`int`型指针的初始值。
```cpp
int null = 0, *p = 0;
```

## 练习 2\.33

```cpp
a = 42; //给int型变量a赋值42
b = 42; //给int型变量b赋值42
c = 42; //给int型变量c赋值42
d = 42; //不合法，d是一个int型指针
e = 42; //不合法，e是一个指向int型常量的指针
g = 42; //不合法，g是一个常量int型引用。
```

## 练习 2\.35

```cpp
const int i = 42;   //i是一个int型常量
auto j = i;         //j是一个int型变量
const auto &k = i;  //k是一个int型常量的引用
auto *p = &i;       //p是一个指向int型常量的指针
const auto j2 = i, &k2 = i;
                    //j2是一个int型常量，k2是一个int型常量的引用
```

## 练习 2\.36

```cpp
int a = 3, b = 4;       //a和b都是一个int型变量
decltype(a) c = a;      //c是一个int型变量，初始值为3
decltype((b)) d = a;    //d是一个int型引用，绑定在a上
++c;                    //c自增变成了4
++d;                    //d自增，因为其绑定在a上，所以a和d都变成了4
                        //abcd全部是4
```

## 练习 2\.37

```cpp
int a = 3, b = 4;       //a和b都是一个int型变量，初始值分别为3和4
decltype(a) c = a;      //c是一个int型变量，初始值为3
decltype(a = b) d = a;  //d是一个int型引用，绑定在a上，即值为3
```

## 练习 2\.38

`decltype`会完全按照表达式的类型来得到结果，而auto通常只会保留底层`const`而忽略顶层`const`，以及`auto`不会直接得到引用。

```cpp
int a = 0;
const int b = 0;
int &r = a;
decltype(a) c = 0;      //auto c = a;   相同
decltype(b) d = 0;      //auto d = b;   不同
decltype(r) e = 0;      //auto e = r;   不同
```

## 练习 2\.39

> t2_39.cpp:8:15: error: expected ‘;’ after struct definition
>     8 | struct Foo { }
>       |               ^
>       |               ;



